<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D/3D å¯è§†åŒ– AST ç¼–è¾‘å™¨</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
      color: white;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      display: grid;
      grid-template-areas:
        "toolbar toolbar toolbar"
        "sidebar canvas panel";
      grid-template-columns: 300px 1fr 300px;
      grid-template-rows: 60px 1fr;
      height: 100vh;
    }

    /* é¡¶éƒ¨å·¥å…·æ  */
    #toolbar {
      grid-area: toolbar;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      padding: 0 20px;
      border-bottom: 1px solid #333;
      backdrop-filter: blur(10px);
    }

    .logo {
      font-size: 24px;
      font-weight: bold;
      margin-right: 30px;
      background: linear-gradient(45deg, #00d4ff, #ff00ff);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .toolbar-buttons {
      display: flex;
      gap: 10px;
    }

    .btn {
      background: linear-gradient(45deg, #667eea, #764ba2);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }

    .btn.active {
      background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    }

    /* å·¦ä¾§è¾¹æ  - ä»£ç ç¼–è¾‘å™¨ */
    #sidebar {
      grid-area: sidebar;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-right: 1px solid #333;
      overflow-y: auto;
    }

    #code-editor {
      width: 100%;
      height: 300px;
      background: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      resize: vertical;
      line-height: 1.5;
    }

    .section {
      margin-bottom: 30px;
    }

    .section h3 {
      margin-bottom: 15px;
      color: #00d4ff;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
    }

    /* ç”»å¸ƒåŒºåŸŸ */
    #canvas-container {
      grid-area: canvas;
      position: relative;
      background: #000;
      overflow: hidden;
    }

    #threejs-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #svg-canvas {
      width: 100%;
      height: 100%;
      display: none;
      background: #1a1a1a;
    }

    /* 2D è§†å›¾æ ·å¼ */
    .ast-node-2d {
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .ast-node-2d:hover {
      stroke-width: 3;
      filter: brightness(1.2);
    }

    .ast-node-2d.selected {
      stroke: #ff6b6b;
      stroke-width: 4;
      filter: drop-shadow(0 0 10px #ff6b6b);
    }

    .ast-connection-2d {
      stroke: #666;
      stroke-width: 2;
      fill: none;
      marker-end: url(#arrowhead);
    }

    .ast-label-2d {
      font-family: 'Segoe UI', sans-serif;
      font-size: 12px;
      fill: white;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    /* ç”»å¸ƒè¦†ç›–å±‚ - ç”¨äº2D UIå…ƒç´  */
    #canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* è§†å›¾æ§åˆ¶å™¨ */
    #view-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 20;
      pointer-events: all;
    }

    .control-group {
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      backdrop-filter: blur(10px);
    }

    .control-row {
      display: flex;
      gap: 5px;
      margin-bottom: 5px;
    }

    .control-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* å³ä¾§é¢æ¿ */
    #panel {
      grid-area: panel;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-left: 1px solid #333;
      overflow-y: auto;
    }

    /* èŠ‚ç‚¹ä¿¡æ¯é¢æ¿ */
    .node-info {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid #333;
    }

    .node-info h4 {
      color: #ff6b6b;
      margin-bottom: 10px;
    }

    .property {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .property-key {
      color: #00d4ff;
    }

    .property-value {
      color: #ffd93d;
    }

    /* ç¼–è¾‘è¡¨å• */
    .edit-form {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #ccc;
      font-size: 14px;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #444;
      border-radius: 6px;
      color: white;
      font-size: 14px;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #00d4ff;
      box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
    }

    /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
    #status {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 20;
      pointer-events: none;
    }

    .status-success {
      border-left: 3px solid #4caf50;
    }

    .status-error {
      border-left: 3px solid #f44336;
    }

    .status-info {
      border-left: 3px solid #2196f3;
    }

    /* è¾“å‡ºé¢æ¿ */
    #output-panel {
      background: #1e1e1e;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      color: #00ff00;
      white-space: pre-wrap;
      min-height: 120px;
      max-height: 200px;
      overflow-y: auto;
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 1200px) {
      #container {
        grid-template-areas:
          "toolbar"
          "canvas"
          "sidebar"
          "panel";
        grid-template-columns: 1fr;
        grid-template-rows: 60px 1fr auto auto;
      }

      #sidebar,
      #panel {
        height: 300px;
      }
    }

    /* åŠ è½½åŠ¨ç”» */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 18px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      margin-right: 15px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-left: 4px solid #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div id="container">
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <div id="toolbar">
      <div class="logo">ğŸŒ³ 3D AST Editor</div>
      <div class="toolbar-buttons">
        <button class="btn" id="parse-btn">ğŸ“– è§£æä»£ç </button>
        <button class="btn" id="view-2d">2ï¸âƒ£ 2Dè§†å›¾</button>
        <button class="btn active" id="view-3d">3ï¸âƒ£ 3Dè§†å›¾</button>
        <button class="btn" id="auto-layout">ğŸ”„ è‡ªåŠ¨å¸ƒå±€</button>
        <button class="btn" id="export-code">ğŸ’¾ å¯¼å‡ºä»£ç </button>
        <button class="btn" id="run-code">â–¶ï¸ è¿è¡Œ</button>
      </div>
    </div>

    <!-- å·¦ä¾§è¾¹æ  - ä»£ç ç¼–è¾‘å™¨ -->
    <div id="sidebar">
      <div class="section">
        <h3>ğŸ“ Python ä»£ç </h3>
        <textarea id="code-editor" placeholder="åœ¨è¿™é‡Œè¾“å…¥ Python ä»£ç ...">def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

def main():
    for i in range(10):
        result = fibonacci(i)
        print(f"fibonacci({i}) = {result}")

if __name__ == "__main__":
    main()</textarea>
      </div>

      <div class="section">
        <h3>ğŸ› ï¸ å¿«é€Ÿæ“ä½œ</h3>
        <div class="form-group">
          <label>æ·»åŠ èŠ‚ç‚¹ç±»å‹</label>
          <select id="node-type-select">
            <option value="FunctionDef">å‡½æ•°å®šä¹‰</option>
            <option value="If">æ¡ä»¶è¯­å¥</option>
            <option value="For">å¾ªç¯è¯­å¥</option>
            <option value="While">Whileå¾ªç¯</option>
            <option value="Assign">èµ‹å€¼è¯­å¥</option>
            <option value="Return">è¿”å›è¯­å¥</option>
            <option value="Print">æ‰“å°è¯­å¥</option>
          </select>
        </div>
        <button class="btn" id="add-node" style="width: 100%;">â• æ·»åŠ èŠ‚ç‚¹</button>
      </div>
    </div>

    <!-- ç”»å¸ƒåŒºåŸŸ -->
    <div id="canvas-container">
      <canvas id="threejs-canvas"></canvas>
      <svg id="svg-canvas">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
          </marker>
        </defs>
      </svg>
      <div id="canvas-overlay"></div>

      <!-- è§†å›¾æ§åˆ¶å™¨ -->
      <div id="view-controls">
        <div class="control-group">
          <div class="control-row">
            <button class="control-btn" id="zoom-in">+</button>
            <button class="control-btn" id="zoom-out">-</button>
            <button class="control-btn" id="reset-view">âŒ‚</button>
          </div>
        </div>
        <div class="control-group">
          <div class="control-row">
            <button class="control-btn" id="rotate-left">â†º</button>
            <button class="control-btn" id="rotate-right">â†»</button>
          </div>
          <div class="control-row">
            <button class="control-btn" id="tilt-up">â†‘</button>
            <button class="control-btn" id="tilt-down">â†“</button>
          </div>
        </div>
      </div>

      <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
      <div id="status" style="display: none;"></div>
    </div>

    <!-- å³ä¾§é¢æ¿ -->
    <div id="panel">
      <div class="section">
        <h3>ğŸ¯ é€‰ä¸­èŠ‚ç‚¹</h3>
        <div id="selected-node-info">
          <div style="text-align: center; color: #666; padding: 40px 20px;">
            ç‚¹å‡»è§†å›¾ä¸­çš„èŠ‚ç‚¹æ¥æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
          </div>
        </div>
      </div>

      <div class="section">
        <h3>âœï¸ ç¼–è¾‘å±æ€§</h3>
        <div id="edit-form-container">
          <div style="text-align: center; color: #666; padding: 40px 20px;">
            é€‰æ‹©èŠ‚ç‚¹åå¯ä»¥åœ¨è¿™é‡Œç¼–è¾‘å…¶å±æ€§
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ğŸ“¤ è¿è¡Œè¾“å‡º</h3>
        <div id="output-panel">ç­‰å¾…ä»£ç æ‰§è¡Œ...</div>
      </div>
    </div>
  </div>

  <!-- Three.js åº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // å…¨å±€å˜é‡
    let scene, camera, renderer, controls;
    let astNodes = new Map();
    let astConnections = [];
    let selectedNode = null;
    let currentAST = null;
    let is3DMode = true;

    // 2D ç›¸å…³å˜é‡
    let svgCanvas, selectedNode2D = null;
    let astNodes2D = new Map();
    let currentLayout = 'tree';

    // API é…ç½®
    const API_URL = 'http://127.0.0.1:5001/api';

    // DOM å…ƒç´ 
    const codeEditor = document.getElementById('code-editor');
    const parseBtn = document.getElementById('parse-btn');
    const view2DBtn = document.getElementById('view-2d');
    const view3DBtn = document.getElementById('view-3d');
    const autoLayoutBtn = document.getElementById('auto-layout');
    const exportCodeBtn = document.getElementById('export-code');
    const runCodeBtn = document.getElementById('run-code');
    const selectedNodeInfo = document.getElementById('selected-node-info');
    const editFormContainer = document.getElementById('edit-form-container');
    const outputPanel = document.getElementById('output-panel');
    const statusDiv = document.getElementById('status');
    const threeJSCanvas = document.getElementById('threejs-canvas');
    const svgCanvasElement = document.getElementById('svg-canvas');

    // åˆå§‹åŒ– Three.js åœºæ™¯
    function initThreeJS() {
      const canvas = document.getElementById('threejs-canvas');
      const container = document.getElementById('canvas-container');

      // åœºæ™¯
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // æ‘„åƒæœº
      camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);

      // æ¸²æŸ“å™¨
      renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // æ§åˆ¶å™¨
      controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI;

      // ç¯å…‰
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // ç‚¹å…‰æº
      const pointLight = new THREE.PointLight(0x00d4ff, 0.8, 100);
      pointLight.position.set(-10, 10, -10);
      scene.add(pointLight);

      // ç½‘æ ¼åœ°é¢
      const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
      scene.add(gridHelper);

      // é¼ æ ‡äº‹ä»¶
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      canvas.addEventListener('click', onCanvasClick);
      canvas.addEventListener('mousemove', onCanvasMouseMove);

      function onCanvasClick(event) {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(Array.from(astNodes.values()));

        if (intersects.length > 0) {
          selectNode(intersects[0].object);
        } else {
          selectNode(null);
        }
      }

      function onCanvasMouseMove(event) {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(Array.from(astNodes.values()));

        canvas.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
      }

      // çª—å£å¤§å°è°ƒæ•´
      window.addEventListener('resize', onWindowResize);

      function onWindowResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      animate();
    }

    // åŠ¨ç”»å¾ªç¯
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // èŠ‚ç‚¹æµ®åŠ¨åŠ¨ç”»
      astNodes.forEach((node, id) => {
        if (node.userData && node.userData.floatOffset !== undefined) {
          node.position.y += Math.sin(Date.now() * 0.001 + node.userData.floatOffset) * 0.002;
        }
      });

      renderer.render(scene, camera);
    }

    // åˆ›å»º AST èŠ‚ç‚¹çš„ 3D è¡¨ç¤º
    function createASTNode(nodeData, position = new THREE.Vector3()) {
      const nodeType = nodeData.node_type || 'Unknown';

      // æ ¹æ®èŠ‚ç‚¹ç±»å‹é€‰æ‹©å½¢çŠ¶å’Œé¢œè‰²
      let geometry, material;

      switch (nodeType) {
        case 'Module':
          geometry = new THREE.SphereGeometry(0.8, 16, 16);
          material = new THREE.MeshPhongMaterial({ color: 0x00d4ff });
          break;
        case 'FunctionDef':
          geometry = new THREE.BoxGeometry(1.5, 1, 1);
          material = new THREE.MeshPhongMaterial({ color: 0xff6b6b });
          break;
        case 'If':
          geometry = new THREE.ConeGeometry(0.8, 1.5, 6);
          material = new THREE.MeshPhongMaterial({ color: 0xffd93d });
          break;
        case 'For':
        case 'While':
          geometry = new THREE.TorusGeometry(0.8, 0.3, 8, 16);
          material = new THREE.MeshPhongMaterial({ color: 0x4ecdc4 });
          break;
        case 'Assign':
          geometry = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 8);
          material = new THREE.MeshPhongMaterial({ color: 0x95e1d3 });
          break;
        case 'Return':
          geometry = new THREE.OctahedronGeometry(0.8);
          material = new THREE.MeshPhongMaterial({ color: 0xf38ba8 });
          break;
        case 'Call':
          geometry = new THREE.TetrahedronGeometry(0.8);
          material = new THREE.MeshPhongMaterial({ color: 0xa8e6cf });
          break;
        default:
          geometry = new THREE.SphereGeometry(0.5, 12, 12);
          material = new THREE.MeshPhongMaterial({ color: 0x888888 });
      }

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      // å­˜å‚¨èŠ‚ç‚¹æ•°æ®
      mesh.userData = {
        nodeData: nodeData,
        nodeType: nodeType,
        floatOffset: Math.random() * Math.PI * 2
      };

      // æ·»åŠ æ–‡æœ¬æ ‡ç­¾
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;

      context.fillStyle = 'rgba(0, 0, 0, 0.8)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      context.fillStyle = 'white';
      context.font = '18px Arial';
      context.textAlign = 'center';
      context.fillText(nodeType, canvas.width / 2, canvas.height / 2 + 6);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(2, 0.5, 1);
      sprite.position.set(0, 1.5, 0);

      mesh.add(sprite);

      return mesh;
    }

    // åˆ›å»ºè¿æ¥çº¿
    function createConnection(fromNode, toNode) {
      const geometry = new THREE.BufferGeometry().setFromPoints([
        fromNode.position,
        toNode.position
      ]);

      const material = new THREE.LineBasicMaterial({
        color: 0x666666,
        transparent: true,
        opacity: 0.6
      });

      const line = new THREE.Line(geometry, material);
      return line;
    }

    // å¯è§†åŒ– AST
    function visualizeAST(ast) {
      // æ¸…é™¤ç°æœ‰èŠ‚ç‚¹
      astNodes.forEach(node => scene.remove(node));
      astConnections.forEach(conn => scene.remove(conn));
      astNodes.clear();
      astConnections = [];

      if (!ast) return;

      // é€’å½’åˆ›å»ºèŠ‚ç‚¹
      const positions = calculateNodePositions(ast);
      createNodesRecursive(ast, positions, null);

      showStatus('AST å¯è§†åŒ–å®Œæˆ', 'success');
    }

    // è®¡ç®—èŠ‚ç‚¹ä½ç½®
    function calculateNodePositions(ast) {
      const positions = new Map();
      let nodeIndex = 0;

      function traverse(node, depth = 0, parentIndex = -1) {
        const currentIndex = nodeIndex++;

        // ä½¿ç”¨èºæ—‹å¸ƒå±€
        const radius = depth * 3 + 2;
        const angle = (currentIndex * 2.4) % (Math.PI * 2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = -depth * 2;

        positions.set(node, { x, y, z, index: currentIndex, parentIndex });

        // é€’å½’å¤„ç†å­èŠ‚ç‚¹
        if (node.body && Array.isArray(node.body)) {
          node.body.forEach(child => traverse(child, depth + 1, currentIndex));
        }

        // å¤„ç†å…¶ä»–å¯èƒ½åŒ…å«å­èŠ‚ç‚¹çš„å±æ€§
        ['orelse', 'finalbody', 'handlers'].forEach(attr => {
          if (node[attr] && Array.isArray(node[attr])) {
            node[attr].forEach(child => traverse(child, depth + 1, currentIndex));
          }
        });
      }

      traverse(ast);
      return positions;
    }

    // é€’å½’åˆ›å»ºèŠ‚ç‚¹
    function createNodesRecursive(node, positions, parentNode) {
      const pos = positions.get(node);
      if (!pos) return;

      const position = new THREE.Vector3(pos.x, pos.y, pos.z);
      const mesh = createASTNode(node, position);

      scene.add(mesh);
      astNodes.set(node, mesh);

      // åˆ›å»ºè¿æ¥çº¿
      if (parentNode) {
        const parentMesh = astNodes.get(parentNode);
        if (parentMesh) {
          const connection = createConnection(parentMesh, mesh);
          scene.add(connection);
          astConnections.push(connection);
        }
      }

      // é€’å½’å¤„ç†å­èŠ‚ç‚¹
      if (node.body && Array.isArray(node.body)) {
        node.body.forEach(child => createNodesRecursive(child, positions, node));
      }

      ['orelse', 'finalbody', 'handlers'].forEach(attr => {
        if (node[attr] && Array.isArray(node[attr])) {
          node[attr].forEach(child => createNodesRecursive(child, positions, node));
        }
      });
    }

    // é€‰æ‹©èŠ‚ç‚¹
    function selectNode(node) {
      // é‡ç½®ä¹‹å‰é€‰æ‹©çš„èŠ‚ç‚¹
      if (selectedNode) {
        selectedNode.material.emissive.setHex(0x000000);
      }

      selectedNode = node;

      if (node) {
        // é«˜äº®é€‰ä¸­çš„èŠ‚ç‚¹
        node.material.emissive.setHex(0x333333);

        // æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
        showNodeInfo(node.userData.nodeData);
        showEditForm(node.userData.nodeData);
      } else {
        // æ¸…ç©ºä¿¡æ¯é¢æ¿
        selectedNodeInfo.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">ç‚¹å‡»3Dè§†å›¾ä¸­çš„èŠ‚ç‚¹æ¥æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</div>';
        editFormContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">é€‰æ‹©èŠ‚ç‚¹åå¯ä»¥åœ¨è¿™é‡Œç¼–è¾‘å…¶å±æ€§</div>';
      }
    }

    // æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
    function showNodeInfo(nodeData) {
      const html = `
        <div class="node-info">
          <h4>${nodeData.node_type || 'Unknown'}</h4>
          ${Object.entries(nodeData)
          .filter(([key, value]) => !['node_type', 'lineno', 'col_offset', 'body', 'orelse', 'finalbody', 'handlers'].includes(key))
          .map(([key, value]) => `
              <div class="property">
                <span class="property-key">${key}:</span>
                <span class="property-value">${JSON.stringify(value)}</span>
              </div>
            `).join('')}
        </div>
      `;
      selectedNodeInfo.innerHTML = html;
    }

    // æ˜¾ç¤ºç¼–è¾‘è¡¨å•
    function showEditForm(nodeData) {
      const nodeType = nodeData.node_type;
      let formHTML = '<div class="edit-form">';

      switch (nodeType) {
        case 'FunctionDef':
          formHTML += `
            <div class="form-group">
              <label>å‡½æ•°å</label>
              <input type="text" id="edit-name" value="${nodeData.name || ''}" />
            </div>
          `;
          break;
        case 'Assign':
          if (nodeData.targets && nodeData.targets[0] && nodeData.targets[0].id) {
            formHTML += `
              <div class="form-group">
                <label>å˜é‡å</label>
                <input type="text" id="edit-var-name" value="${nodeData.targets[0].id}" />
              </div>
            `;
          }
          break;
        case 'Constant':
          formHTML += `
            <div class="form-group">
              <label>å¸¸é‡å€¼</label>
              <input type="text" id="edit-value" value="${nodeData.value || ''}" />
            </div>
          `;
          break;
      }

      formHTML += `
        <button class="btn" onclick="applyNodeEdit()" style="width: 100%; margin-top: 10px;">âœ… åº”ç”¨ä¿®æ”¹</button>
        <button class="btn" onclick="deleteNode()" style="width: 100%; margin-top: 5px; background: linear-gradient(45deg, #f44336, #d32f2f);">ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹</button>
      </div>
      `;

      editFormContainer.innerHTML = formHTML;
    }

    // åº”ç”¨èŠ‚ç‚¹ç¼–è¾‘
    function applyNodeEdit() {
      if (!selectedNode) return;

      const nodeData = selectedNode.userData.nodeData;
      const nameInput = document.getElementById('edit-name');
      const varNameInput = document.getElementById('edit-var-name');
      const valueInput = document.getElementById('edit-value');

      if (nameInput && nameInput.value !== nodeData.name) {
        nodeData.name = nameInput.value;
        showStatus('å‡½æ•°åå·²æ›´æ–°', 'success');
      }

      if (varNameInput && nodeData.targets && nodeData.targets[0]) {
        nodeData.targets[0].id = varNameInput.value;
        showStatus('å˜é‡åå·²æ›´æ–°', 'success');
      }

      if (valueInput) {
        try {
          nodeData.value = JSON.parse(valueInput.value);
          showStatus('å¸¸é‡å€¼å·²æ›´æ–°', 'success');
        } catch (e) {
          nodeData.value = valueInput.value;
          showStatus('å¸¸é‡å€¼å·²æ›´æ–°', 'success');
        }
      }

      // åˆ·æ–°æ˜¾ç¤º
      showNodeInfo(nodeData);
    }

    // åˆ é™¤èŠ‚ç‚¹
    function deleteNode() {
      if (!selectedNode) return;

      // ä»åœºæ™¯ä¸­ç§»é™¤
      scene.remove(selectedNode);

      // ç§»é™¤ç›¸å…³è¿æ¥
      astConnections = astConnections.filter(conn => {
        if (conn.geometry.attributes.position.array.some((_, i) => {
          const point = new THREE.Vector3().fromArray(conn.geometry.attributes.position.array, i * 3);
          return point.distanceTo(selectedNode.position) < 0.1;
        })) {
          scene.remove(conn);
          return false;
        }
        return true;
      });

      // ä»æ˜ å°„ä¸­ç§»é™¤
      for (const [node, mesh] of astNodes.entries()) {
        if (mesh === selectedNode) {
          astNodes.delete(node);
          break;
        }
      }

      selectNode(null);
      showStatus('èŠ‚ç‚¹å·²åˆ é™¤', 'success');
    }

    // API è°ƒç”¨
    async function apiCall(endpoint, data) {
      try {
        const response = await fetch(`${API_URL}/${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || 'è¯·æ±‚å¤±è´¥');
        }

        return result;
      } catch (error) {
        showStatus(`é”™è¯¯: ${error.message}`, 'error');
        throw error;
      }
    }

    // è§£æä»£ç 
    async function parseCode() {
      try {
        parseBtn.textContent = 'è§£æä¸­...';
        parseBtn.disabled = true;

        const code = codeEditor.value;
        if (!code.trim()) {
          throw new Error('è¯·è¾“å…¥ä»£ç ');
        }

        const result = await apiCall('parse', { code });
        currentAST = result.ast;

        visualizeAST(currentAST);
        showStatus('ä»£ç è§£ææˆåŠŸ', 'success');

      } catch (error) {
        showStatus(`è§£æå¤±è´¥: ${error.message}`, 'error');
      } finally {
        parseBtn.textContent = 'ğŸ“– è§£æä»£ç ';
        parseBtn.disabled = false;
      }
    }

    // å¯¼å‡ºä»£ç 
    async function exportCode() {
      if (!currentAST) {
        showStatus('è¯·å…ˆè§£æä»£ç ', 'error');
        return;
      }

      try {
        const result = await apiCall('unparse', { ast: currentAST });
        codeEditor.value = result.code;
        showStatus('ä»£ç å·²æ›´æ–°', 'success');
      } catch (error) {
        showStatus(`å¯¼å‡ºå¤±è´¥: ${error.message}`, 'error');
      }
    }

    // è¿è¡Œä»£ç 
    async function runCode() {
      try {
        runCodeBtn.textContent = 'è¿è¡Œä¸­...';
        runCodeBtn.disabled = true;
        outputPanel.textContent = 'æ‰§è¡Œä¸­...';

        const code = codeEditor.value;
        if (!code.trim()) {
          throw new Error('è¯·è¾“å…¥ä»£ç ');
        }

        const result = await apiCall('execute', { code });

        let output = '';
        if (result.output) {
          output += result.output;
        }
        if (result.error) {
          output += '\n[é”™è¯¯è¾“å‡º]\n' + result.error;
        }

        outputPanel.textContent = output || '(æ— è¾“å‡º)';
        showStatus('ä»£ç æ‰§è¡Œå®Œæˆ', 'success');

      } catch (error) {
        outputPanel.textContent = `æ‰§è¡Œé”™è¯¯: ${error.message}`;
        showStatus(`æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
      } finally {
        runCodeBtn.textContent = 'â–¶ï¸ è¿è¡Œ';
        runCodeBtn.disabled = false;
      }
    }

    // æ˜¾ç¤ºçŠ¶æ€
    function showStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status-${type}`;
      statusDiv.style.display = 'block';

      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }

    // è‡ªåŠ¨å¸ƒå±€
    function autoLayout() {
      if (!currentAST) return;

      // é‡æ–°è®¡ç®—ä½ç½®å¹¶æ›´æ–°
      const positions = calculateNodePositions(currentAST);

      astNodes.forEach((mesh, node) => {
        const pos = positions.get(node);
        if (pos) {
          // å¹³æ»‘åŠ¨ç”»åˆ°æ–°ä½ç½®
          const targetPosition = new THREE.Vector3(pos.x, pos.y, pos.z);

          const startPosition = mesh.position.clone();
          const duration = 1000; // 1ç§’
          const startTime = Date.now();

          function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
            const easing = 1 - Math.pow(1 - progress, 3);

            mesh.position.lerpVectors(startPosition, targetPosition, easing);

            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }

          animate();
        }
      });

      // æ›´æ–°è¿æ¥çº¿
      setTimeout(() => {
        astConnections.forEach(conn => {
          scene.remove(conn);
        });
        astConnections = [];

        // é‡æ–°åˆ›å»ºè¿æ¥çº¿
        astNodes.forEach((mesh, node) => {
          if (node.body && Array.isArray(node.body)) {
            node.body.forEach(child => {
              const childMesh = astNodes.get(child);
              if (childMesh) {
                const connection = createConnection(mesh, childMesh);
                scene.add(connection);
                astConnections.push(connection);
              }
            });
          }
        });
      }, 1000);

      showStatus('å¸ƒå±€å·²æ›´æ–°', 'success');
    }

    // 2D å¯è§†åŒ–å‡½æ•°
    function init2D() {
      svgCanvas = svgCanvasElement;
    }

    function visualizeAST2D(astData, layout = 'tree') {
      // æ¸…ç©ºç°æœ‰å†…å®¹
      while (svgCanvas.children.length > 1) { // ä¿ç•™ defs
        svgCanvas.removeChild(svgCanvas.lastChild);
      }
      astNodes2D.clear();

      // è®¡ç®—2Då¸ƒå±€
      const nodes = extractNodes2D(astData);
      const positions = calculate2DLayout(nodes, layout);

      // ç»˜åˆ¶è¿æ¥çº¿
      drawConnections2D(nodes, positions);

      // ç»˜åˆ¶èŠ‚ç‚¹
      drawNodes2D(nodes, positions);
    }

    function extractNodes2D(astData) {
      const nodes = [];

      function traverse(node, parent = null, depth = 0) {
        if (!node || typeof node !== 'object') return;

        const nodeInfo = {
          id: `node_${nodes.length}`,
          type: node.node_type || 'Unknown',
          name: node.name || '',
          value: node.value || '',
          parent: parent,
          children: [],
          depth: depth,
          data: node
        };

        nodes.push(nodeInfo);

        // å¤„ç†å­èŠ‚ç‚¹
        ['body', 'orelse', 'finalbody', 'handlers'].forEach(key => {
          if (node[key] && Array.isArray(node[key])) {
            node[key].forEach(child => {
              const childNode = traverse(child, nodeInfo, depth + 1);
              if (childNode) nodeInfo.children.push(childNode);
            });
          }
        });

        // å¤„ç†å…¶ä»–å•ä¸ªå­èŠ‚ç‚¹
        Object.values(node).forEach(value => {
          if (value && typeof value === 'object' && value.node_type && !Array.isArray(value)) {
            const childNode = traverse(value, nodeInfo, depth + 1);
            if (childNode) nodeInfo.children.push(childNode);
          }
        });

        return nodeInfo;
      }

      if (astData && astData.node_type) {
        traverse(astData);
      }

      return nodes;
    }

    function calculate2DLayout(nodes, layout) {
      const positions = new Map();
      const rect = svgCanvas.getBoundingClientRect();
      const width = rect.width || 800;
      const height = rect.height || 600;

      if (layout === 'tree') {
        // æ ‘å½¢å¸ƒå±€
        const levels = {};
        nodes.forEach(node => {
          if (!levels[node.depth]) levels[node.depth] = [];
          levels[node.depth].push(node);
        });

        Object.keys(levels).forEach(depth => {
          const levelNodes = levels[depth];
          const levelHeight = (height / (Object.keys(levels).length + 1)) * (parseInt(depth) + 1);

          levelNodes.forEach((node, index) => {
            const x = (width / (levelNodes.length + 1)) * (index + 1);
            positions.set(node.id, { x, y: levelHeight });
          });
        });
      } else if (layout === 'radial') {
        // å¾„å‘å¸ƒå±€
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) / 3;

        nodes.forEach((node, index) => {
          if (index === 0) {
            // æ ¹èŠ‚ç‚¹åœ¨ä¸­å¿ƒ
            positions.set(node.id, { x: centerX, y: centerY });
          } else {
            const radius = (node.depth) * (maxRadius / 4);
            const angle = (index / nodes.length) * 2 * Math.PI;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            positions.set(node.id, { x, y });
          }
        });
      } else {
        // é»˜è®¤ç½‘æ ¼å¸ƒå±€
        const cols = Math.ceil(Math.sqrt(nodes.length));
        const cellWidth = width / cols;
        const cellHeight = height / Math.ceil(nodes.length / cols);

        nodes.forEach((node, index) => {
          const col = index % cols;
          const row = Math.floor(index / cols);
          const x = (col + 0.5) * cellWidth;
          const y = (row + 0.5) * cellHeight;
          positions.set(node.id, { x, y });
        });
      }

      return positions;
    }

    function drawNodes2D(nodes, positions) {
      nodes.forEach(node => {
        const pos = positions.get(node.id);
        if (!pos) return;

        // åˆ›å»ºèŠ‚ç‚¹ç»„
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('class', 'ast-node-2d');
        group.setAttribute('data-node-id', node.id);

        // æ ¹æ®èŠ‚ç‚¹ç±»å‹é€‰æ‹©é¢œè‰²å’Œå½¢çŠ¶
        const nodeColor = getNodeColor2D(node.type);
        const nodeSize = getNodeSize2D(node.type);

        // ç»˜åˆ¶èŠ‚ç‚¹å½¢çŠ¶
        let shape;
        if (['FunctionDef', 'ClassDef'].includes(node.type)) {
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          shape.setAttribute('x', pos.x - nodeSize / 2);
          shape.setAttribute('y', pos.y - nodeSize / 2);
          shape.setAttribute('width', nodeSize);
          shape.setAttribute('height', nodeSize);
          shape.setAttribute('rx', 5);
        } else {
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          shape.setAttribute('cx', pos.x);
          shape.setAttribute('cy', pos.y);
          shape.setAttribute('r', nodeSize / 2);
        }

        shape.setAttribute('fill', nodeColor);
        shape.setAttribute('stroke', '#fff');
        shape.setAttribute('stroke-width', 2);

        // æ·»åŠ æ–‡æœ¬æ ‡ç­¾
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', pos.x);
        text.setAttribute('y', pos.y + 4);
        text.setAttribute('class', 'ast-label-2d');
        text.textContent = node.name || node.type || 'Node';

        // æ·»åŠ äº‹ä»¶ç›‘å¬
        group.addEventListener('click', () => selectNode2D(node, group));
        group.addEventListener('mouseenter', () => {
          group.style.filter = 'brightness(1.2)';
        });
        group.addEventListener('mouseleave', () => {
          if (selectedNode2D !== group) {
            group.style.filter = '';
          }
        });

        group.appendChild(shape);
        group.appendChild(text);
        svgCanvas.appendChild(group);

        astNodes2D.set(node.id, { node, element: group });
      });
    }

    function drawConnections2D(nodes, positions) {
      nodes.forEach(node => {
        if (node.parent) {
          const fromPos = positions.get(node.parent.id);
          const toPos = positions.get(node.id);

          if (fromPos && toPos) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x);
            line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x);
            line.setAttribute('y2', toPos.y);
            line.setAttribute('class', 'ast-connection-2d');

            // æ’å…¥åˆ°èŠ‚ç‚¹ä¹‹å‰
            svgCanvas.insertBefore(line, svgCanvas.children[1]);
          }
        }
      });
    }

    function getNodeColor2D(nodeType) {
      const colors = {
        'Module': '#00d4ff',
        'FunctionDef': '#ff6b6b',
        'ClassDef': '#ff9500',
        'If': '#ffd93d',
        'For': '#4ecdc4',
        'While': '#45b7d1',
        'Try': '#96ceb4',
        'Assign': '#95e1d3',
        'Return': '#f38ba8',
        'Call': '#a8e6cf',
        'Name': '#90caf9',
        'Constant': '#a5d6a7'
      };
      return colors[nodeType] || '#888888';
    }

    function getNodeSize2D(nodeType) {
      const sizes = {
        'Module': 60,
        'FunctionDef': 50,
        'ClassDef': 50,
        'If': 40,
        'For': 40,
        'While': 40,
        'Try': 40,
        'Assign': 35,
        'Return': 35,
        'Call': 30,
        'Name': 25,
        'Constant': 25
      };
      return sizes[nodeType] || 30;
    }

    function selectNode2D(node, element) {
      // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
      if (selectedNode2D) {
        selectedNode2D.classList.remove('selected');
        selectedNode2D.style.filter = '';
      }

      // é€‰æ‹©æ–°èŠ‚ç‚¹
      selectedNode2D = element;
      element.classList.add('selected');
      element.style.filter = 'brightness(1.2)';

      // æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
      showNodeInfo(node.data);
      showEditForm(node.data);
    }

    // è§†å›¾åˆ‡æ¢
    function toggleView(is3D) {
      is3DMode = is3D;

      if (is3D) {
        view3DBtn.classList.add('active');
        view2DBtn.classList.remove('active');
        threeJSCanvas.style.display = 'block';
        svgCanvasElement.style.display = 'none';

        // å¦‚æœæœ‰ASTæ•°æ®ï¼Œé‡æ–°æ¸²æŸ“3Dè§†å›¾
        if (currentAST) {
          visualizeAST(currentAST);
        }
      } else {
        view2DBtn.classList.add('active');
        view3DBtn.classList.remove('active');
        threeJSCanvas.style.display = 'none';
        svgCanvasElement.style.display = 'block';

        // å¦‚æœæœ‰ASTæ•°æ®ï¼Œæ¸²æŸ“2Dè§†å›¾
        if (currentAST) {
          visualizeAST2D(currentAST, currentLayout);
        }
      }
    }

    // è§†å›¾æ§åˆ¶
    function setupViewControls() {
      document.getElementById('zoom-in').onclick = () => {
        camera.position.multiplyScalar(0.9);
      };

      document.getElementById('zoom-out').onclick = () => {
        camera.position.multiplyScalar(1.1);
      };

      document.getElementById('reset-view').onclick = () => {
        controls.reset();
        camera.position.set(0, 5, 10);
      };

      document.getElementById('rotate-left').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.2);
      };

      document.getElementById('rotate-right').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -0.2);
      };

      document.getElementById('tilt-up').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), 0.2);
      };

      document.getElementById('tilt-down').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), -0.2);
      };
    }

    // äº‹ä»¶ç›‘å¬å™¨
    parseBtn.onclick = parseCode;
    view2DBtn.onclick = () => toggleView(false);
    view3DBtn.onclick = () => toggleView(true);
    autoLayoutBtn.onclick = autoLayout;
    exportCodeBtn.onclick = exportCode;
    runCodeBtn.onclick = runCode;

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', () => {
      initThreeJS();
      init2D();
      setupViewControls();
      showStatus('2D/3D AST ç¼–è¾‘å™¨å·²å°±ç»ª', 'info');
    });
  </script>
</body>

</html>