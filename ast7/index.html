<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D/3D 可视化 AST 编辑器</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
      color: white;
      overflow: hidden;
      height: 100vh;
    }

    #container {
      display: grid;
      grid-template-areas:
        "toolbar toolbar toolbar"
        "sidebar canvas panel";
      grid-template-columns: 300px 1fr 300px;
      grid-template-rows: 60px 1fr;
      height: 100vh;
    }

    /* 顶部工具栏 */
    #toolbar {
      grid-area: toolbar;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      padding: 0 20px;
      border-bottom: 1px solid #333;
      backdrop-filter: blur(10px);
    }

    .logo {
      font-size: 24px;
      font-weight: bold;
      margin-right: 30px;
      background: linear-gradient(45deg, #00d4ff, #ff00ff);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .toolbar-buttons {
      display: flex;
      gap: 10px;
    }

    .btn {
      background: linear-gradient(45deg, #667eea, #764ba2);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }

    .btn.active {
      background: linear-gradient(45deg, #ff6b6b, #ee5a52);
    }

    /* 左侧边栏 - 代码编辑器 */
    #sidebar {
      grid-area: sidebar;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-right: 1px solid #333;
      overflow-y: auto;
    }

    #code-editor {
      width: 100%;
      height: 300px;
      background: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      resize: vertical;
      line-height: 1.5;
    }

    .section {
      margin-bottom: 30px;
    }

    .section h3 {
      margin-bottom: 15px;
      color: #00d4ff;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
    }

    /* 画布区域 */
    #canvas-container {
      grid-area: canvas;
      position: relative;
      background: #000;
      overflow: hidden;
    }

    #threejs-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #svg-canvas {
      width: 100%;
      height: 100%;
      display: none;
      background: #1a1a1a;
    }

    /* 2D 视图样式 */
    .ast-node-2d {
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .ast-node-2d:hover {
      stroke-width: 3;
      filter: brightness(1.2);
    }

    .ast-node-2d.selected {
      stroke: #ff6b6b;
      stroke-width: 4;
      filter: drop-shadow(0 0 10px #ff6b6b);
    }

    .ast-connection-2d {
      stroke: #666;
      stroke-width: 2;
      fill: none;
      marker-end: url(#arrowhead);
    }

    .ast-label-2d {
      font-family: 'Segoe UI', sans-serif;
      font-size: 12px;
      fill: white;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    /* 画布覆盖层 - 用于2D UI元素 */
    #canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* 视图控制器 */
    #view-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 20;
      pointer-events: all;
    }

    .control-group {
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      backdrop-filter: blur(10px);
    }

    .control-row {
      display: flex;
      gap: 5px;
      margin-bottom: 5px;
    }

    .control-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* 右侧面板 */
    #panel {
      grid-area: panel;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-left: 1px solid #333;
      overflow-y: auto;
    }

    /* 节点信息面板 */
    .node-info {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid #333;
    }

    .node-info h4 {
      color: #ff6b6b;
      margin-bottom: 10px;
    }

    .property {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .property-key {
      color: #00d4ff;
    }

    .property-value {
      color: #ffd93d;
    }

    /* 编辑表单 */
    .edit-form {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #ccc;
      font-size: 14px;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #444;
      border-radius: 6px;
      color: white;
      font-size: 14px;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #00d4ff;
      box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
    }

    /* 状态指示器 */
    #status {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 20;
      pointer-events: none;
    }

    .status-success {
      border-left: 3px solid #4caf50;
    }

    .status-error {
      border-left: 3px solid #f44336;
    }

    .status-info {
      border-left: 3px solid #2196f3;
    }

    /* 输出面板 */
    #output-panel {
      background: #1e1e1e;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      color: #00ff00;
      white-space: pre-wrap;
      min-height: 120px;
      max-height: 200px;
      overflow-y: auto;
    }

    /* 响应式设计 */
    @media (max-width: 1200px) {
      #container {
        grid-template-areas:
          "toolbar"
          "canvas"
          "sidebar"
          "panel";
        grid-template-columns: 1fr;
        grid-template-rows: 60px 1fr auto auto;
      }

      #sidebar,
      #panel {
        height: 300px;
      }
    }

    /* 加载动画 */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 18px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      margin-right: 15px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-left: 4px solid #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div id="container">
    <!-- 顶部工具栏 -->
    <div id="toolbar">
      <div class="logo">🌳 3D AST Editor</div>
      <div class="toolbar-buttons">
        <button class="btn" id="parse-btn">📖 解析代码</button>
        <button class="btn" id="view-2d">2️⃣ 2D视图</button>
        <button class="btn active" id="view-3d">3️⃣ 3D视图</button>
        <button class="btn" id="auto-layout">🔄 自动布局</button>
        <button class="btn" id="export-code">💾 导出代码</button>
        <button class="btn" id="run-code">▶️ 运行</button>
      </div>
    </div>

    <!-- 左侧边栏 - 代码编辑器 -->
    <div id="sidebar">
      <div class="section">
        <h3>📝 Python 代码</h3>
        <textarea id="code-editor" placeholder="在这里输入 Python 代码...">def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

def main():
    for i in range(10):
        result = fibonacci(i)
        print(f"fibonacci({i}) = {result}")

if __name__ == "__main__":
    main()</textarea>
      </div>

      <div class="section">
        <h3>🛠️ 快速操作</h3>
        <div class="form-group">
          <label>添加节点类型</label>
          <select id="node-type-select">
            <option value="FunctionDef">函数定义</option>
            <option value="If">条件语句</option>
            <option value="For">循环语句</option>
            <option value="While">While循环</option>
            <option value="Assign">赋值语句</option>
            <option value="Return">返回语句</option>
            <option value="Print">打印语句</option>
          </select>
        </div>
        <button class="btn" id="add-node" style="width: 100%;">➕ 添加节点</button>
      </div>
    </div>

    <!-- 画布区域 -->
    <div id="canvas-container">
      <canvas id="threejs-canvas"></canvas>
      <svg id="svg-canvas">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
          </marker>
        </defs>
      </svg>
      <div id="canvas-overlay"></div>

      <!-- 视图控制器 -->
      <div id="view-controls">
        <div class="control-group">
          <div class="control-row">
            <button class="control-btn" id="zoom-in">+</button>
            <button class="control-btn" id="zoom-out">-</button>
            <button class="control-btn" id="reset-view">⌂</button>
          </div>
        </div>
        <div class="control-group">
          <div class="control-row">
            <button class="control-btn" id="rotate-left">↺</button>
            <button class="control-btn" id="rotate-right">↻</button>
          </div>
          <div class="control-row">
            <button class="control-btn" id="tilt-up">↑</button>
            <button class="control-btn" id="tilt-down">↓</button>
          </div>
        </div>
      </div>

      <!-- 状态指示器 -->
      <div id="status" style="display: none;"></div>
    </div>

    <!-- 右侧面板 -->
    <div id="panel">
      <div class="section">
        <h3>🎯 选中节点</h3>
        <div id="selected-node-info">
          <div style="text-align: center; color: #666; padding: 40px 20px;">
            点击视图中的节点来查看详细信息
          </div>
        </div>
      </div>

      <div class="section">
        <h3>✏️ 编辑属性</h3>
        <div id="edit-form-container">
          <div style="text-align: center; color: #666; padding: 40px 20px;">
            选择节点后可以在这里编辑其属性
          </div>
        </div>
      </div>

      <div class="section">
        <h3>📤 运行输出</h3>
        <div id="output-panel">等待代码执行...</div>
      </div>
    </div>
  </div>

  <!-- Three.js 库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // 全局变量
    let scene, camera, renderer, controls;
    let astNodes = new Map();
    let astConnections = [];
    let selectedNode = null;
    let currentAST = null;
    let is3DMode = true;

    // 2D 相关变量
    let svgCanvas, selectedNode2D = null;
    let astNodes2D = new Map();
    let currentLayout = 'tree';

    // API 配置
    const API_URL = 'http://127.0.0.1:5001/api';

    // DOM 元素
    const codeEditor = document.getElementById('code-editor');
    const parseBtn = document.getElementById('parse-btn');
    const view2DBtn = document.getElementById('view-2d');
    const view3DBtn = document.getElementById('view-3d');
    const autoLayoutBtn = document.getElementById('auto-layout');
    const exportCodeBtn = document.getElementById('export-code');
    const runCodeBtn = document.getElementById('run-code');
    const selectedNodeInfo = document.getElementById('selected-node-info');
    const editFormContainer = document.getElementById('edit-form-container');
    const outputPanel = document.getElementById('output-panel');
    const statusDiv = document.getElementById('status');
    const threeJSCanvas = document.getElementById('threejs-canvas');
    const svgCanvasElement = document.getElementById('svg-canvas');

    // 初始化 Three.js 场景
    function initThreeJS() {
      const canvas = document.getElementById('threejs-canvas');
      const container = document.getElementById('canvas-container');

      // 场景
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // 摄像机
      camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);

      // 渲染器
      renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // 控制器
      controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI;

      // 灯光
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // 点光源
      const pointLight = new THREE.PointLight(0x00d4ff, 0.8, 100);
      pointLight.position.set(-10, 10, -10);
      scene.add(pointLight);

      // 网格地面
      const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
      scene.add(gridHelper);

      // 鼠标事件
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      canvas.addEventListener('click', onCanvasClick);
      canvas.addEventListener('mousemove', onCanvasMouseMove);

      function onCanvasClick(event) {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(Array.from(astNodes.values()));

        if (intersects.length > 0) {
          selectNode(intersects[0].object);
        } else {
          selectNode(null);
        }
      }

      function onCanvasMouseMove(event) {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(Array.from(astNodes.values()));

        canvas.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
      }

      // 窗口大小调整
      window.addEventListener('resize', onWindowResize);

      function onWindowResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      animate();
    }

    // 动画循环
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // 节点浮动动画
      astNodes.forEach((node, id) => {
        if (node.userData && node.userData.floatOffset !== undefined) {
          node.position.y += Math.sin(Date.now() * 0.001 + node.userData.floatOffset) * 0.002;
        }
      });

      renderer.render(scene, camera);
    }

    // 创建 AST 节点的 3D 表示
    function createASTNode(nodeData, position = new THREE.Vector3()) {
      const nodeType = nodeData.node_type || 'Unknown';

      // 根据节点类型选择形状和颜色
      let geometry, material;

      switch (nodeType) {
        case 'Module':
          geometry = new THREE.SphereGeometry(0.8, 16, 16);
          material = new THREE.MeshPhongMaterial({ color: 0x00d4ff });
          break;
        case 'FunctionDef':
          geometry = new THREE.BoxGeometry(1.5, 1, 1);
          material = new THREE.MeshPhongMaterial({ color: 0xff6b6b });
          break;
        case 'If':
          geometry = new THREE.ConeGeometry(0.8, 1.5, 6);
          material = new THREE.MeshPhongMaterial({ color: 0xffd93d });
          break;
        case 'For':
        case 'While':
          geometry = new THREE.TorusGeometry(0.8, 0.3, 8, 16);
          material = new THREE.MeshPhongMaterial({ color: 0x4ecdc4 });
          break;
        case 'Assign':
          geometry = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 8);
          material = new THREE.MeshPhongMaterial({ color: 0x95e1d3 });
          break;
        case 'Return':
          geometry = new THREE.OctahedronGeometry(0.8);
          material = new THREE.MeshPhongMaterial({ color: 0xf38ba8 });
          break;
        case 'Call':
          geometry = new THREE.TetrahedronGeometry(0.8);
          material = new THREE.MeshPhongMaterial({ color: 0xa8e6cf });
          break;
        default:
          geometry = new THREE.SphereGeometry(0.5, 12, 12);
          material = new THREE.MeshPhongMaterial({ color: 0x888888 });
      }

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      // 存储节点数据
      mesh.userData = {
        nodeData: nodeData,
        nodeType: nodeType,
        floatOffset: Math.random() * Math.PI * 2
      };

      // 添加文本标签
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;

      context.fillStyle = 'rgba(0, 0, 0, 0.8)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      context.fillStyle = 'white';
      context.font = '18px Arial';
      context.textAlign = 'center';
      context.fillText(nodeType, canvas.width / 2, canvas.height / 2 + 6);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(2, 0.5, 1);
      sprite.position.set(0, 1.5, 0);

      mesh.add(sprite);

      return mesh;
    }

    // 创建连接线
    function createConnection(fromNode, toNode) {
      const geometry = new THREE.BufferGeometry().setFromPoints([
        fromNode.position,
        toNode.position
      ]);

      const material = new THREE.LineBasicMaterial({
        color: 0x666666,
        transparent: true,
        opacity: 0.6
      });

      const line = new THREE.Line(geometry, material);
      return line;
    }

    // 可视化 AST
    function visualizeAST(ast) {
      // 清除现有节点
      astNodes.forEach(node => scene.remove(node));
      astConnections.forEach(conn => scene.remove(conn));
      astNodes.clear();
      astConnections = [];

      if (!ast) return;

      // 递归创建节点
      const positions = calculateNodePositions(ast);
      createNodesRecursive(ast, positions, null);

      showStatus('AST 可视化完成', 'success');
    }

    // 计算节点位置
    function calculateNodePositions(ast) {
      const positions = new Map();
      let nodeIndex = 0;

      function traverse(node, depth = 0, parentIndex = -1) {
        const currentIndex = nodeIndex++;

        // 使用螺旋布局
        const radius = depth * 3 + 2;
        const angle = (currentIndex * 2.4) % (Math.PI * 2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = -depth * 2;

        positions.set(node, { x, y, z, index: currentIndex, parentIndex });

        // 递归处理子节点
        if (node.body && Array.isArray(node.body)) {
          node.body.forEach(child => traverse(child, depth + 1, currentIndex));
        }

        // 处理其他可能包含子节点的属性
        ['orelse', 'finalbody', 'handlers'].forEach(attr => {
          if (node[attr] && Array.isArray(node[attr])) {
            node[attr].forEach(child => traverse(child, depth + 1, currentIndex));
          }
        });
      }

      traverse(ast);
      return positions;
    }

    // 递归创建节点
    function createNodesRecursive(node, positions, parentNode) {
      const pos = positions.get(node);
      if (!pos) return;

      const position = new THREE.Vector3(pos.x, pos.y, pos.z);
      const mesh = createASTNode(node, position);

      scene.add(mesh);
      astNodes.set(node, mesh);

      // 创建连接线
      if (parentNode) {
        const parentMesh = astNodes.get(parentNode);
        if (parentMesh) {
          const connection = createConnection(parentMesh, mesh);
          scene.add(connection);
          astConnections.push(connection);
        }
      }

      // 递归处理子节点
      if (node.body && Array.isArray(node.body)) {
        node.body.forEach(child => createNodesRecursive(child, positions, node));
      }

      ['orelse', 'finalbody', 'handlers'].forEach(attr => {
        if (node[attr] && Array.isArray(node[attr])) {
          node[attr].forEach(child => createNodesRecursive(child, positions, node));
        }
      });
    }

    // 选择节点
    function selectNode(node) {
      // 重置之前选择的节点
      if (selectedNode) {
        selectedNode.material.emissive.setHex(0x000000);
      }

      selectedNode = node;

      if (node) {
        // 高亮选中的节点
        node.material.emissive.setHex(0x333333);

        // 显示节点信息
        showNodeInfo(node.userData.nodeData);
        showEditForm(node.userData.nodeData);
      } else {
        // 清空信息面板
        selectedNodeInfo.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">点击3D视图中的节点来查看详细信息</div>';
        editFormContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">选择节点后可以在这里编辑其属性</div>';
      }
    }

    // 显示节点信息
    function showNodeInfo(nodeData) {
      const html = `
        <div class="node-info">
          <h4>${nodeData.node_type || 'Unknown'}</h4>
          ${Object.entries(nodeData)
          .filter(([key, value]) => !['node_type', 'lineno', 'col_offset', 'body', 'orelse', 'finalbody', 'handlers'].includes(key))
          .map(([key, value]) => `
              <div class="property">
                <span class="property-key">${key}:</span>
                <span class="property-value">${JSON.stringify(value)}</span>
              </div>
            `).join('')}
        </div>
      `;
      selectedNodeInfo.innerHTML = html;
    }

    // 显示编辑表单
    function showEditForm(nodeData) {
      const nodeType = nodeData.node_type;
      let formHTML = '<div class="edit-form">';

      switch (nodeType) {
        case 'FunctionDef':
          formHTML += `
            <div class="form-group">
              <label>函数名</label>
              <input type="text" id="edit-name" value="${nodeData.name || ''}" />
            </div>
          `;
          break;
        case 'Assign':
          if (nodeData.targets && nodeData.targets[0] && nodeData.targets[0].id) {
            formHTML += `
              <div class="form-group">
                <label>变量名</label>
                <input type="text" id="edit-var-name" value="${nodeData.targets[0].id}" />
              </div>
            `;
          }
          break;
        case 'Constant':
          formHTML += `
            <div class="form-group">
              <label>常量值</label>
              <input type="text" id="edit-value" value="${nodeData.value || ''}" />
            </div>
          `;
          break;
      }

      formHTML += `
        <button class="btn" onclick="applyNodeEdit()" style="width: 100%; margin-top: 10px;">✅ 应用修改</button>
        <button class="btn" onclick="deleteNode()" style="width: 100%; margin-top: 5px; background: linear-gradient(45deg, #f44336, #d32f2f);">🗑️ 删除节点</button>
      </div>
      `;

      editFormContainer.innerHTML = formHTML;
    }

    // 应用节点编辑
    function applyNodeEdit() {
      if (!selectedNode) return;

      const nodeData = selectedNode.userData.nodeData;
      const nameInput = document.getElementById('edit-name');
      const varNameInput = document.getElementById('edit-var-name');
      const valueInput = document.getElementById('edit-value');

      if (nameInput && nameInput.value !== nodeData.name) {
        nodeData.name = nameInput.value;
        showStatus('函数名已更新', 'success');
      }

      if (varNameInput && nodeData.targets && nodeData.targets[0]) {
        nodeData.targets[0].id = varNameInput.value;
        showStatus('变量名已更新', 'success');
      }

      if (valueInput) {
        try {
          nodeData.value = JSON.parse(valueInput.value);
          showStatus('常量值已更新', 'success');
        } catch (e) {
          nodeData.value = valueInput.value;
          showStatus('常量值已更新', 'success');
        }
      }

      // 刷新显示
      showNodeInfo(nodeData);
    }

    // 删除节点
    function deleteNode() {
      if (!selectedNode) return;

      // 从场景中移除
      scene.remove(selectedNode);

      // 移除相关连接
      astConnections = astConnections.filter(conn => {
        if (conn.geometry.attributes.position.array.some((_, i) => {
          const point = new THREE.Vector3().fromArray(conn.geometry.attributes.position.array, i * 3);
          return point.distanceTo(selectedNode.position) < 0.1;
        })) {
          scene.remove(conn);
          return false;
        }
        return true;
      });

      // 从映射中移除
      for (const [node, mesh] of astNodes.entries()) {
        if (mesh === selectedNode) {
          astNodes.delete(node);
          break;
        }
      }

      selectNode(null);
      showStatus('节点已删除', 'success');
    }

    // API 调用
    async function apiCall(endpoint, data) {
      try {
        const response = await fetch(`${API_URL}/${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });

        const result = await response.json();
        if (!result.success) {
          throw new Error(result.error || '请求失败');
        }

        return result;
      } catch (error) {
        showStatus(`错误: ${error.message}`, 'error');
        throw error;
      }
    }

    // 解析代码
    async function parseCode() {
      try {
        parseBtn.textContent = '解析中...';
        parseBtn.disabled = true;

        const code = codeEditor.value;
        if (!code.trim()) {
          throw new Error('请输入代码');
        }

        const result = await apiCall('parse', { code });
        currentAST = result.ast;

        visualizeAST(currentAST);
        showStatus('代码解析成功', 'success');

      } catch (error) {
        showStatus(`解析失败: ${error.message}`, 'error');
      } finally {
        parseBtn.textContent = '📖 解析代码';
        parseBtn.disabled = false;
      }
    }

    // 导出代码
    async function exportCode() {
      if (!currentAST) {
        showStatus('请先解析代码', 'error');
        return;
      }

      try {
        const result = await apiCall('unparse', { ast: currentAST });
        codeEditor.value = result.code;
        showStatus('代码已更新', 'success');
      } catch (error) {
        showStatus(`导出失败: ${error.message}`, 'error');
      }
    }

    // 运行代码
    async function runCode() {
      try {
        runCodeBtn.textContent = '运行中...';
        runCodeBtn.disabled = true;
        outputPanel.textContent = '执行中...';

        const code = codeEditor.value;
        if (!code.trim()) {
          throw new Error('请输入代码');
        }

        const result = await apiCall('execute', { code });

        let output = '';
        if (result.output) {
          output += result.output;
        }
        if (result.error) {
          output += '\n[错误输出]\n' + result.error;
        }

        outputPanel.textContent = output || '(无输出)';
        showStatus('代码执行完成', 'success');

      } catch (error) {
        outputPanel.textContent = `执行错误: ${error.message}`;
        showStatus(`执行失败: ${error.message}`, 'error');
      } finally {
        runCodeBtn.textContent = '▶️ 运行';
        runCodeBtn.disabled = false;
      }
    }

    // 显示状态
    function showStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = `status-${type}`;
      statusDiv.style.display = 'block';

      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }

    // 自动布局
    function autoLayout() {
      if (!currentAST) return;

      // 重新计算位置并更新
      const positions = calculateNodePositions(currentAST);

      astNodes.forEach((mesh, node) => {
        const pos = positions.get(node);
        if (pos) {
          // 平滑动画到新位置
          const targetPosition = new THREE.Vector3(pos.x, pos.y, pos.z);

          const startPosition = mesh.position.clone();
          const duration = 1000; // 1秒
          const startTime = Date.now();

          function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // 使用缓动函数
            const easing = 1 - Math.pow(1 - progress, 3);

            mesh.position.lerpVectors(startPosition, targetPosition, easing);

            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }

          animate();
        }
      });

      // 更新连接线
      setTimeout(() => {
        astConnections.forEach(conn => {
          scene.remove(conn);
        });
        astConnections = [];

        // 重新创建连接线
        astNodes.forEach((mesh, node) => {
          if (node.body && Array.isArray(node.body)) {
            node.body.forEach(child => {
              const childMesh = astNodes.get(child);
              if (childMesh) {
                const connection = createConnection(mesh, childMesh);
                scene.add(connection);
                astConnections.push(connection);
              }
            });
          }
        });
      }, 1000);

      showStatus('布局已更新', 'success');
    }

    // 2D 可视化函数
    function init2D() {
      svgCanvas = svgCanvasElement;
    }

    function visualizeAST2D(astData, layout = 'tree') {
      // 清空现有内容
      while (svgCanvas.children.length > 1) { // 保留 defs
        svgCanvas.removeChild(svgCanvas.lastChild);
      }
      astNodes2D.clear();

      // 计算2D布局
      const nodes = extractNodes2D(astData);
      const positions = calculate2DLayout(nodes, layout);

      // 绘制连接线
      drawConnections2D(nodes, positions);

      // 绘制节点
      drawNodes2D(nodes, positions);
    }

    function extractNodes2D(astData) {
      const nodes = [];

      function traverse(node, parent = null, depth = 0) {
        if (!node || typeof node !== 'object') return;

        const nodeInfo = {
          id: `node_${nodes.length}`,
          type: node.node_type || 'Unknown',
          name: node.name || '',
          value: node.value || '',
          parent: parent,
          children: [],
          depth: depth,
          data: node
        };

        nodes.push(nodeInfo);

        // 处理子节点
        ['body', 'orelse', 'finalbody', 'handlers'].forEach(key => {
          if (node[key] && Array.isArray(node[key])) {
            node[key].forEach(child => {
              const childNode = traverse(child, nodeInfo, depth + 1);
              if (childNode) nodeInfo.children.push(childNode);
            });
          }
        });

        // 处理其他单个子节点
        Object.values(node).forEach(value => {
          if (value && typeof value === 'object' && value.node_type && !Array.isArray(value)) {
            const childNode = traverse(value, nodeInfo, depth + 1);
            if (childNode) nodeInfo.children.push(childNode);
          }
        });

        return nodeInfo;
      }

      if (astData && astData.node_type) {
        traverse(astData);
      }

      return nodes;
    }

    function calculate2DLayout(nodes, layout) {
      const positions = new Map();
      const rect = svgCanvas.getBoundingClientRect();
      const width = rect.width || 800;
      const height = rect.height || 600;

      if (layout === 'tree') {
        // 树形布局
        const levels = {};
        nodes.forEach(node => {
          if (!levels[node.depth]) levels[node.depth] = [];
          levels[node.depth].push(node);
        });

        Object.keys(levels).forEach(depth => {
          const levelNodes = levels[depth];
          const levelHeight = (height / (Object.keys(levels).length + 1)) * (parseInt(depth) + 1);

          levelNodes.forEach((node, index) => {
            const x = (width / (levelNodes.length + 1)) * (index + 1);
            positions.set(node.id, { x, y: levelHeight });
          });
        });
      } else if (layout === 'radial') {
        // 径向布局
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) / 3;

        nodes.forEach((node, index) => {
          if (index === 0) {
            // 根节点在中心
            positions.set(node.id, { x: centerX, y: centerY });
          } else {
            const radius = (node.depth) * (maxRadius / 4);
            const angle = (index / nodes.length) * 2 * Math.PI;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            positions.set(node.id, { x, y });
          }
        });
      } else {
        // 默认网格布局
        const cols = Math.ceil(Math.sqrt(nodes.length));
        const cellWidth = width / cols;
        const cellHeight = height / Math.ceil(nodes.length / cols);

        nodes.forEach((node, index) => {
          const col = index % cols;
          const row = Math.floor(index / cols);
          const x = (col + 0.5) * cellWidth;
          const y = (row + 0.5) * cellHeight;
          positions.set(node.id, { x, y });
        });
      }

      return positions;
    }

    function drawNodes2D(nodes, positions) {
      nodes.forEach(node => {
        const pos = positions.get(node.id);
        if (!pos) return;

        // 创建节点组
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('class', 'ast-node-2d');
        group.setAttribute('data-node-id', node.id);

        // 根据节点类型选择颜色和形状
        const nodeColor = getNodeColor2D(node.type);
        const nodeSize = getNodeSize2D(node.type);

        // 绘制节点形状
        let shape;
        if (['FunctionDef', 'ClassDef'].includes(node.type)) {
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          shape.setAttribute('x', pos.x - nodeSize / 2);
          shape.setAttribute('y', pos.y - nodeSize / 2);
          shape.setAttribute('width', nodeSize);
          shape.setAttribute('height', nodeSize);
          shape.setAttribute('rx', 5);
        } else {
          shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          shape.setAttribute('cx', pos.x);
          shape.setAttribute('cy', pos.y);
          shape.setAttribute('r', nodeSize / 2);
        }

        shape.setAttribute('fill', nodeColor);
        shape.setAttribute('stroke', '#fff');
        shape.setAttribute('stroke-width', 2);

        // 添加文本标签
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', pos.x);
        text.setAttribute('y', pos.y + 4);
        text.setAttribute('class', 'ast-label-2d');
        text.textContent = node.name || node.type || 'Node';

        // 添加事件监听
        group.addEventListener('click', () => selectNode2D(node, group));
        group.addEventListener('mouseenter', () => {
          group.style.filter = 'brightness(1.2)';
        });
        group.addEventListener('mouseleave', () => {
          if (selectedNode2D !== group) {
            group.style.filter = '';
          }
        });

        group.appendChild(shape);
        group.appendChild(text);
        svgCanvas.appendChild(group);

        astNodes2D.set(node.id, { node, element: group });
      });
    }

    function drawConnections2D(nodes, positions) {
      nodes.forEach(node => {
        if (node.parent) {
          const fromPos = positions.get(node.parent.id);
          const toPos = positions.get(node.id);

          if (fromPos && toPos) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x);
            line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x);
            line.setAttribute('y2', toPos.y);
            line.setAttribute('class', 'ast-connection-2d');

            // 插入到节点之前
            svgCanvas.insertBefore(line, svgCanvas.children[1]);
          }
        }
      });
    }

    function getNodeColor2D(nodeType) {
      const colors = {
        'Module': '#00d4ff',
        'FunctionDef': '#ff6b6b',
        'ClassDef': '#ff9500',
        'If': '#ffd93d',
        'For': '#4ecdc4',
        'While': '#45b7d1',
        'Try': '#96ceb4',
        'Assign': '#95e1d3',
        'Return': '#f38ba8',
        'Call': '#a8e6cf',
        'Name': '#90caf9',
        'Constant': '#a5d6a7'
      };
      return colors[nodeType] || '#888888';
    }

    function getNodeSize2D(nodeType) {
      const sizes = {
        'Module': 60,
        'FunctionDef': 50,
        'ClassDef': 50,
        'If': 40,
        'For': 40,
        'While': 40,
        'Try': 40,
        'Assign': 35,
        'Return': 35,
        'Call': 30,
        'Name': 25,
        'Constant': 25
      };
      return sizes[nodeType] || 30;
    }

    function selectNode2D(node, element) {
      // 清除之前的选择
      if (selectedNode2D) {
        selectedNode2D.classList.remove('selected');
        selectedNode2D.style.filter = '';
      }

      // 选择新节点
      selectedNode2D = element;
      element.classList.add('selected');
      element.style.filter = 'brightness(1.2)';

      // 显示节点信息
      showNodeInfo(node.data);
      showEditForm(node.data);
    }

    // 视图切换
    function toggleView(is3D) {
      is3DMode = is3D;

      if (is3D) {
        view3DBtn.classList.add('active');
        view2DBtn.classList.remove('active');
        threeJSCanvas.style.display = 'block';
        svgCanvasElement.style.display = 'none';

        // 如果有AST数据，重新渲染3D视图
        if (currentAST) {
          visualizeAST(currentAST);
        }
      } else {
        view2DBtn.classList.add('active');
        view3DBtn.classList.remove('active');
        threeJSCanvas.style.display = 'none';
        svgCanvasElement.style.display = 'block';

        // 如果有AST数据，渲染2D视图
        if (currentAST) {
          visualizeAST2D(currentAST, currentLayout);
        }
      }
    }

    // 视图控制
    function setupViewControls() {
      document.getElementById('zoom-in').onclick = () => {
        camera.position.multiplyScalar(0.9);
      };

      document.getElementById('zoom-out').onclick = () => {
        camera.position.multiplyScalar(1.1);
      };

      document.getElementById('reset-view').onclick = () => {
        controls.reset();
        camera.position.set(0, 5, 10);
      };

      document.getElementById('rotate-left').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.2);
      };

      document.getElementById('rotate-right').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -0.2);
      };

      document.getElementById('tilt-up').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), 0.2);
      };

      document.getElementById('tilt-down').onclick = () => {
        camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), -0.2);
      };
    }

    // 事件监听器
    parseBtn.onclick = parseCode;
    view2DBtn.onclick = () => toggleView(false);
    view3DBtn.onclick = () => toggleView(true);
    autoLayoutBtn.onclick = autoLayout;
    exportCodeBtn.onclick = exportCode;
    runCodeBtn.onclick = runCode;

    // 初始化
    document.addEventListener('DOMContentLoaded', () => {
      initThreeJS();
      init2D();
      setupViewControls();
      showStatus('2D/3D AST 编辑器已就绪', 'info');
    });
  </script>
</body>

</html>